import {
  writable
} from "./chunk-DY7FSUYH.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  binding_callbacks,
  children,
  claim_element,
  component_subscribe,
  detach_dev,
  dispatch_dev,
  element,
  globals,
  init,
  insert_hydration_dev,
  noop,
  onMount,
  safe_not_equal,
  validate_slots,
  validate_store
} from "./chunk-K6MJRMI7.js";

// node_modules/@codewithshin/svelte-utterances/theme.js
import { browser } from "$app/environment";
var defaultValue = "icy-dark";
var initialValue = browser ? window.localStorage.getItem("utterancesTheme") ?? defaultValue : defaultValue;
var utterancesTheme = writable(defaultValue);
utterancesTheme.subscribe((value) => {
  if (browser) {
    window.localStorage.setItem("utterancesTheme", value);
  }
});
var theme_default = utterancesTheme;

// node_modules/@codewithshin/svelte-utterances/Utterances.svelte
var { console: console_1 } = globals;
var file = "node_modules\\@codewithshin\\svelte-utterances\\Utterances.svelte";
function create_fragment(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file, 56, 0, 1472);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[6](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[6](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $utterancesTheme;
  validate_store(theme_default, "utterancesTheme");
  component_subscribe($$self, theme_default, ($$value) => $$invalidate(8, $utterancesTheme = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Utterances", slots, []);
  let { reponame } = $$props;
  let { issueTerm = "pathname" } = $$props;
  let { label = "comments" } = $$props;
  let { theme = $utterancesTheme } = $$props;
  let divElm;
  let scriptElm;
  let browser2 = false;
  const sendPostMessage = () => {
    const iFrame = divElm.getElementsByClassName("utterances-frame")[0];
    if (!iFrame) {
      setTimeout(sendPostMessage, 100);
      return;
    }
    iFrame.contentWindow.postMessage({ type: "set-theme", theme }, "https://utteranc.es");
  };
  onMount(() => {
    scriptElm = document.createElement("script");
    scriptElm.setAttribute("repo", reponame);
    scriptElm.setAttribute("issue-term", issueTerm);
    scriptElm.setAttribute("label", label);
    scriptElm.setAttribute("crossorigin", "anonymous");
    scriptElm.src = "https://utteranc.es/client.js";
    divElm.appendChild(scriptElm);
    $$invalidate(5, browser2 = true);
    sendPostMessage();
  });
  $$self.$$.on_mount.push(function() {
    if (reponame === void 0 && !("reponame" in $$props || $$self.$$.bound[$$self.$$.props["reponame"]])) {
      console_1.warn("<Utterances> was created without expected prop 'reponame'");
    }
  });
  const writable_props = ["reponame", "issueTerm", "label", "theme"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<Utterances> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      divElm = $$value;
      $$invalidate(0, divElm);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("reponame" in $$props2)
      $$invalidate(1, reponame = $$props2.reponame);
    if ("issueTerm" in $$props2)
      $$invalidate(2, issueTerm = $$props2.issueTerm);
    if ("label" in $$props2)
      $$invalidate(3, label = $$props2.label);
    if ("theme" in $$props2)
      $$invalidate(4, theme = $$props2.theme);
  };
  $$self.$capture_state = () => ({
    utterancesTheme: theme_default,
    onMount,
    reponame,
    issueTerm,
    label,
    theme,
    divElm,
    scriptElm,
    browser: browser2,
    sendPostMessage,
    $utterancesTheme
  });
  $$self.$inject_state = ($$props2) => {
    if ("reponame" in $$props2)
      $$invalidate(1, reponame = $$props2.reponame);
    if ("issueTerm" in $$props2)
      $$invalidate(2, issueTerm = $$props2.issueTerm);
    if ("label" in $$props2)
      $$invalidate(3, label = $$props2.label);
    if ("theme" in $$props2)
      $$invalidate(4, theme = $$props2.theme);
    if ("divElm" in $$props2)
      $$invalidate(0, divElm = $$props2.divElm);
    if ("scriptElm" in $$props2)
      scriptElm = $$props2.scriptElm;
    if ("browser" in $$props2)
      $$invalidate(5, browser2 = $$props2.browser);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*browser, divElm, theme*/
    49) {
      $: {
        try {
          const iFrame = browser2 && divElm.getElementsByClassName("utterances-frame")[0];
          if (iFrame) {
            iFrame.contentWindow.postMessage({ type: "set-theme", theme }, "https://utteranc.es");
          }
        } catch (e) {
          console.log("error", e);
        }
      }
    }
  };
  return [divElm, reponame, issueTerm, label, theme, browser2, div_binding];
}
var Utterances = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      reponame: 1,
      issueTerm: 2,
      label: 3,
      theme: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Utterances",
      options,
      id: create_fragment.name
    });
  }
  get reponame() {
    throw new Error("<Utterances>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reponame(value) {
    throw new Error("<Utterances>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get issueTerm() {
    throw new Error("<Utterances>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set issueTerm(value) {
    throw new Error("<Utterances>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Utterances>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Utterances>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Utterances>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Utterances>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Utterances_default = Utterances;
export {
  Utterances_default as Utterances,
  theme_default as utterancesTheme
};
//# sourceMappingURL=@codewithshin_svelte-utterances.js.map
